{
  "hash": "a504b56692e2863656dd37d28b3e7abf",
  "result": {
    "markdown": "---\ntitle: \"Sampling and Simulation\"\nauthor: Jose Toledo Luna\ntoc: true\ndate: October 27, 2023\n---\n\n\n\n\n## Sampling\n\nWe can obtain a random sample from existing elements in a dataset, vector, or list using the `sample()` function in R\n\nThe basic syntax for the `sample()` function is as follows:\n\n`sample(x,size,replace = FALSE, prob = NULL)`\n\n* `x`: object we are sampling from, most often a vector or dataset\n* `size`: size of the sample\n* `replace`: should sampling be with replacement? *(FALSE by default)*\n* `prob`: A vector of probability weights for obtaining the elements of the vector being sampled *(NULL by default, every element is equally likely to be drawn)*\n\nFor more details on the sample function run `?sample` in the console\n\nIn order to replicate the following examples and get similar results, we can use `set.seed()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\n```\n:::\n\n\nSuppose we have a vector with 10 elements in it\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec <- 1:10\n```\n:::\n\n\nTo generate a random sample of five elements from our vector `vec`, we run the following command\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsample(vec,size = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1]  3 10  2  8  6\n```\n:::\n:::\n\n\nRecall, the default setting for sampling is without replacement. This means once we draw the number *(or element)* from our vector we can not draw it again, similar to the lottery method.\n\nIt is also important to note that each time we run the command `sample()` it may generate a different set of elements each time\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsample(vec,size = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] 5 4 6 8 1\n```\n:::\n:::\n\n\nWe can also sample random elements from our vector using the argument `replace=TRUE` so that we are sampling with replacement. That is, each time we draw an element we put it back into our vector and there may be a chance we draw it again. So each element in the vector can be chosen to be in the random sample more than once\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsample(vec,size=5,replace = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] 10  5  3  9  9\n```\n:::\n:::\n\n\n\n`sample()` can be applied not only to numerical vectors, but other types of vectors such as character or logical.\n\nFor example, consider the character vector with the following names from our class. No one is volunteering so I randomly choose a set of three people in the class\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstudents <- c('Leslie', 'Ron', 'Andy', 'April', 'Tom', 'Ben', 'Jerry')\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsample(students, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] \"Leslie\" \"Tom\"    \"Andy\"\n```\n:::\n:::\n\n\nIn this scenario sampling with replacement *(i.e replace = TRUE)* would not be appropriate\n\n\nOne important application for sampling is splitting up our dataset into two sets: one for training and one for testing an algorithm. \n\nWe will consider the penguins dataset from the `palmerpenguins` library\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat <- palmerpenguins::penguins\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nnrow(dat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] 344\n```\n:::\n:::\n\n\nIn order to sample random rows from a dataset you first have to create a vector from `1:nrow(data)`, these will be the indices we will sample from\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrow_indices <- 1:nrow(dat)\n```\n:::\n\n\nOur training set will consist of 80% of the dataset and testing set will consist of the remaining 20%\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrain_sampled_rows <- sample(row_indices, size= 0.8*nrow(dat) )\n```\n:::\n\n*Interpretation: randomly select 80% (approx. 275) rows from 1:344*\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrain_sampled_rows[1:10]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#>  [1] 328  26   7 137 254 211  78  81  43 332\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntraining_set <- dat[train_sampled_rows,]\ndim(training_set)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] 275   8\n```\n:::\n:::\n\n\nlastly, we use the remaining rows for our testing set\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_set <- dat[-train_sampled_rows, ]\ndim(test_set)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] 69  8\n```\n:::\n:::\n\n\n\n## Simulation \n\n\nLet start with a simple example by simulating a fair dice roll \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsample(1:6,size=1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] 2\n```\n:::\n:::\n\n\nsince we are only drawing once, it doesn't matter if you sample with or without replacement\n\n\nNow, consider rolling two fair, six-sided dice and computing their sum. One approach to compute this would be \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndice1 <- sample(1:6, size=1)\ndice2 <- sample(1:6, size=1)\ndice1 + dice2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] 9\n```\n:::\n:::\n\n\nAn easier way:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nroll_two_dice <- sample(1:6,size = 2,replace = TRUE)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(roll_two_dice)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] 10\n```\n:::\n:::\n\n\nWe are drawing two numbers from the range 1 through 6 *with replacement*. We sample with replacement because the roll of each dice is independent and it's possible to roll *(or draw)* the same number twice. If we were to use `replace=FALSE` once we draw, say 1, we could not draw 1 again for the second dice.\n\nFrom the above examples, it is straightforward to carry out a simple random experiment. What if we wanted to repeat these experiment multiple times? For example, we wanted to repeat the experiment of drawing two dice and calculating their sum 100 or even 1000 times. For such scenarios we can utilize the `replicate()` function in R.\n\n\n`replicate()` implements common tasks involving `for` loops without explicitly having to use looping syntax. \n\nThe basic syntax for the `replicate()` function is as follows:\n\n`replicate(n,expr, simplify = 'array')`\n\n* `n`: number of replications. *How many times do you want to replicate the experiment*\n\n* `expr`: the expression to evaluate repeatedly\n\n* `simplify`: how the output should be returned. The default is an `array`. If `simplify=FALSE`, the output will be a list of `n` elements\n\nLet's start by simulating sampling 3 different numbers from ranges 1 to 20 at random without replacement, 10 times. \n\nBreaking it down, first we \ncreate our expression *(or experiment)* \n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(10)\nsample(1:20, size=3, replace=FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] 11  9 10\n```\n:::\n:::\n\n\nthen replicate this experiment 10 times \n\n\n::: {.cell}\n\n```{.r .cell-code}\nreplicate(n = 10, \n          expr = sample(1:20, size=3, replace=FALSE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n#> [1,]   16    7   15   10    8    6   18    1    4    11\n#> [2,]   12   19   10    2   14    7   13    7   18    15\n#> [3,]    8   15    7   13    7   18    5   18   19     1\n```\n:::\n:::\n\n\nThe default output of `replicate()` will be an `array` with `n` columns, the rows will depend on the length of the output from the experiment. For example, we are sampling 3 numbers from 1-20 so we will have three rows, each column will then correspond to a replicate of the experiment. So in the first replicate we drew the numbers (16,12,8). In the second replicate we drew the numbers (7,19,15), and similar interpretations hold for the remaining columns *(replicates)*\n\nGoing back to our example of calculating the sum of rolling  two fair dice. We will replicate this experiment `n` times\n\nWe will use `replicate` as follows:\n1. Write a function that performs the experiment once\n2. Replicate the experiment using `replicate()` many times\n\n**Creating a function**\n\nWe can create a function that will calculate the sum of rolling two fair dice as follows\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum_dice_roll <- function(){\n  dice_roll <- sample(1:6, size=2,replace = TRUE)\n  return(sum(dice_roll))\n}\n```\n:::\n\n\nThe sum of rolling two fair dice once was \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum_dice_roll()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] 6\n```\n:::\n:::\n\n\n**Replicate experiment multiple times**\n\nLet's start by calculating the sum of rolling two fair dice 20 times\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreplicate(n = 20,\n          expr = sum_dice_roll() )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#>  [1]  5 11  2  6  3  7  8  9  9  4  4  4  8 10  8  7  5  8  8  4\n```\n:::\n:::\n\n\nreplicating our experiment 100 times\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrep100 <- replicate(n = 100,\n                    expr = sum_dice_roll())\n```\n:::\n\n\nIf we were to repeat this experiment many times, what is the sum that will most likely occur in the long run ?\n\nLooking at our experiment replicated 100 times we obtain the following relative frequency of every outcome. Note the possible outcomes are (2,3,4,...12)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprop.table( table(rep100) ) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> rep100\n#>    2    3    4    5    6    7    8    9   10   11   12 \n#> 0.01 0.04 0.06 0.07 0.14 0.21 0.09 0.12 0.14 0.08 0.04\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbarplot( prop.table(table(rep100)),\n         xlab = 'Sum', ylab = 'Relative Frequency')\n```\n\n::: {.cell-output-display}\n![](08-sampling_simulation_files/figure-html/unnamed-chunk-26-1.png){width=576}\n:::\n:::\n\n\nReplicating our experiments many more times, say 10,000 times,\nwe will obtain more stable results which comes from the idea of \"long-run\" behavior. According to the law of large numbers, if we repeat an experiment independently a large number of times and average the result, we should obtain a value which is close to the actual expected value.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrep10000 <- replicate(n = 10000,\n                    expr = sum_dice_roll())\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprop.table( table(rep10000) ) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> rep10000\n#>      2      3      4      5      6      7      8      9     10     11     12 \n#> 0.0285 0.0566 0.0810 0.1155 0.1418 0.1645 0.1372 0.1125 0.0805 0.0560 0.0259\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbarplot( prop.table(table(rep10000)),\n         xlab = 'Sum', ylab = 'Relative Frequency')\n```\n\n::: {.cell-output-display}\n![](08-sampling_simulation_files/figure-html/unnamed-chunk-29-1.png){width=576}\n:::\n:::\n\n\nDepending on the context of the problem 10,000 may not be considered large, but for the given dice roll experiment 10,000 is enough. The more replicates you perform the longer time it will take to run on your computer.\n\n",
    "supporting": [
      "08-sampling_simulation_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}