{
  "hash": "0113e2fdd4990f49eee7b79b8504795c",
  "result": {
    "markdown": "---\nauthor: Jose Toledo Luna\ntitle: Introduction to For-Loops\ntoc: true\ndate: October 27, 2023\n---\n\n\n\nA for-loop serves the purpose of cycling through a collection of objects, such as a vector, list, matrix, or dataframe, and consistently applying a specific set of operations to each element within the data structure\n\n\nThe syntax of a for-loop in R consists of a `variable` which takes items from the `iterable` one by one, where the `iterable` is the collection of objects provided *(vector, list, matrix, etc..)*\n\nLastly, inside the for-loop within the curly braces `{ }` is the `loop body` which are statements that are executed once for each item in the `iterable` provided\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor(variable in iterable) {\n  loop body\n}\n```\n:::\n\n\n\nUtilizing for-loops helps maintain code cleanliness and prevents unnecessary duplication of code blocks\n\n\n\nTo start with a basic example, consider printing the numbers from `1 to 5` inclusive, this is our `iterable` and is constructed using any sequence operator. This can be `a:b` or the built-in function `seq()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (index in 1:5){\n  print(index)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n```\n:::\n:::\n\n\n\nHere `index` is our `variable`, the variable name can be anything but it is usually in the context of the problem\n\n\nFor example, this can be anything from `car`,`letters`, `months`, etc.., in most cases usually the variable name `i` suffices \n\nOur `loop body` is simply to `print()` the current index\n\n\n### Using a For-Loop on a vector\n\n\nIn the next example, we will print the numbers from `1 to 5` and then double each number before printing it\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor(i in 1:5){\n  print(i*2)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n[1] 4\n[1] 6\n[1] 8\n[1] 10\n```\n:::\n:::\n\n\n\n\nHowever, there are scenarios where we not only want to print these values but also store them after each iteration. To do that, we need to start by creating an empty object. This object can be new or an existing one, but it's important to keep in mind that after each iteration, the object may be modified\n\n\nThe function `numeric()` creates a numeric vector of all `0` of a specified `length`. Here the `length`, should be the the same size as the `iterable`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec <- numeric(length = 5)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nvec\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0 0 0 0 0\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfor(i in 1:5){\n  print(paste0('Current Iteration: ',i) ) #<1>\n  \n  vec[i] <- (i*2)  #<2>\n  \n  print(vec) #<3>\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Current Iteration: 1\"\n[1] 2 0 0 0 0\n[1] \"Current Iteration: 2\"\n[1] 2 4 0 0 0\n[1] \"Current Iteration: 3\"\n[1] 2 4 6 0 0\n[1] \"Current Iteration: 4\"\n[1] 2 4 6 8 0\n[1] \"Current Iteration: 5\"\n[1]  2  4  6  8 10\n```\n:::\n:::\n\n1. Print the current iteration *(optional)*\n2. Update the $i$th element of the vector `vec` by doubling the current index\n3. Print the updated vector `vec` *(optional)*\n\n\nHere is the resulting vector\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  2  4  6  8 10\n```\n:::\n:::\n\n\n:::callout-warning\nIn R, for-loops tend to be slow. To mitigate the performance issues associated with for-loops, it is often recommended to use vectorized operations or apply functions\n:::\n\n\nFor example, \n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec <- 2*(1:5)\nvec\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  2  4  6  8 10\n```\n:::\n:::\n\n\nIt is clear there was no need to use a for-loop in the previous example it was simply for teaching purposes\n\nWe don't need to iterate sequentially from a regular sequence `1:N`. We can iterate through the elements of an existing object. For example,\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor(i in 3:6){\n  print(i)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfor(i in seq(from = 1, to = 11, by = 2)){\n  print(i)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n[1] 3\n[1] 5\n[1] 7\n[1] 9\n[1] 11\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfor(pet in c('dog','cat','hamster','turtle')){\n  print(pet)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"dog\"\n[1] \"cat\"\n[1] \"hamster\"\n[1] \"turtle\"\n```\n:::\n:::\n\n\n\nHowever, if you are trying to update the $i$th element of an object this approach might not be the best\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec <- numeric(length=3)\n\nfor(index in c(2,4,6) ){\n  print( vec[index] )\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n[1] NA\n[1] NA\n```\n:::\n:::\n\n\nAn `NA` is produced because our vector `vec` has three elements and we are trying to access the 4th and 6th element which do not exist \n\nInstead use the function `seq_along(x)` which will create a regular sequence from `1:length(x)`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq_along(c(2,4,6))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nseq_along(c('dog','cat','hamster','turtle'))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfor(index in seq_along(c(2,4,6)) ){\n  print(index)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n[1] 2\n[1] 3\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}